const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":67,\"nextId\":67,\"documentIds\":{\"0\":\"0\",\"1\":\"0#hi-there-👋\",\"2\":\"2\",\"3\":\"3\",\"4\":\"3@0\",\"5\":\"3@1\",\"6\":\"4\",\"7\":\"4@0\",\"8\":\"4@1\",\"9\":\"5\",\"10\":\"5#for循环\",\"11\":\"5#定义一个一维数组\",\"12\":\"5#初始化赋值\",\"13\":\"5#定义一个二维数组\",\"14\":\"5#初始化\",\"15\":\"5#注意\",\"16\":\"5#字符数组\",\"17\":\"5#定义成字符串\",\"18\":\"5#输入输出\",\"19\":\"5#如果包含空格\",\"20\":\"5#输入\",\"21\":\"5#使用字符串处理函数-有string-h头文件\",\"22\":\"5#定义函数\",\"23\":\"5#调用函数\",\"24\":\"5#函数调用时的数据传递\",\"25\":\"5#形式参数和实际参数\",\"26\":\"5#函数的嵌套调用\",\"27\":\"5#递归调用\",\"28\":\"5#数组作为函数的参数\",\"29\":\"5#关于指针\",\"30\":\"5#定义指针\",\"31\":\"5#赋值语句运算符\",\"32\":\"5#声明指针\",\"33\":\"5#注意-1\",\"34\":\"5#指针变量的引用\",\"35\":\"5#指针引用数组\",\"36\":\"5#指针的运算\",\"37\":\"5#指向函数的指针\",\"38\":\"5#一般形式\",\"39\":\"5#结构体的声明\",\"40\":\"5#引用结构体变量中成员的方式为\",\"41\":\"5#声明新类型名\",\"42\":\"5#链表\",\"43\":\"5@0\",\"44\":\"5@1\",\"45\":\"6\",\"46\":\"6#判断闰年\",\"47\":\"6#计算正整数的长度\",\"48\":\"6#幂函数\",\"49\":\"6#判断回文数\",\"50\":\"6@0\",\"51\":\"6@1\",\"52\":\"7\",\"53\":\"7#直接量\",\"54\":\"7#变量\",\"55\":\"7#运算符\",\"56\":\"7#布尔型\",\"57\":\"7#位运算符\",\"58\":\"7#class\",\"59\":\"7#成员域\",\"60\":\"7#构造方法\",\"61\":\"7#枚举\",\"62\":\"7@0\",\"63\":\"7@1\",\"64\":\"8\",\"65\":\"9\",\"66\":\"10\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[3,27],\"2\":[1,27],\"3\":[1,7],\"4\":[null,null,1],\"5\":[null,null,2],\"6\":[1,7],\"7\":[null,null,1],\"8\":[null,null,2],\"9\":[2],\"10\":[1,30],\"11\":[1,8],\"12\":[1,22],\"13\":[1,7],\"14\":[1,10],\"15\":[1,1],\"16\":[1,13],\"17\":[1,9],\"18\":[1,6],\"19\":[1,2],\"20\":[1,6],\"21\":[4,36],\"22\":[1,29],\"23\":[1,6],\"24\":[1],\"25\":[1,13],\"26\":[1,2],\"27\":[1,2],\"28\":[1,5],\"29\":[1,5],\"30\":[1,3],\"31\":[1,11],\"32\":[1,13],\"33\":[1,10],\"34\":[1,8],\"35\":[1,1],\"36\":[1,19],\"37\":[1,11],\"38\":[1],\"39\":[1,6],\"40\":[1,5],\"41\":[1,13],\"42\":[1,3],\"43\":[null,null,1],\"44\":[null,null,2],\"45\":[1],\"46\":[1,23],\"47\":[1,6],\"48\":[1,16],\"49\":[1,43],\"50\":[null,null,1],\"51\":[null,null,2],\"52\":[2,28],\"53\":[1,13],\"54\":[1,6],\"55\":[1,14],\"56\":[1,9],\"57\":[1,23],\"58\":[1,20],\"59\":[1,21],\"60\":[1,61],\"61\":[1,6],\"62\":[null,null,1],\"63\":[null,null,2],\"64\":[1,3],\"65\":[1],\"66\":[1]},\"averageFieldLength\":[1.147158324762428,13.229289213570022,0.8077071462488129],\"storedFields\":{\"0\":{\"h\":\"Buterr的blog\",\"t\":[\"Buterr的blog\"]},\"1\":{\"h\":\"Hi there 👋\",\"t\":[\"I'm a student from Beijing University of Posts and Telecommunications, now I'm trying to use Github to learn something about coding. Life will be better with code.\"]},\"2\":{\"h\":\"个人介绍\",\"t\":[\"I'm a student from Beijing University of Posts and Telecommunications, now I'm trying to use Github to learn something about coding. Life will be better with code.\"]},\"3\":{\"h\":\"博客文章样例\",\"t\":[\"博客文章内容，支持 Markdown 和 HTML 语言。\"]},\"4\":{\"c\":[\"使用指南\"]},\"5\":{\"c\":[\"页面配置\",\"使用指南\"]},\"6\":{\"h\":\"博客文章样例2\",\"t\":[\"博客文章内容，支持 Markdown 和 HTML 语言。\"]},\"7\":{\"c\":[\"工具\"]},\"8\":{\"c\":[\"页面配置\",\"使用指南\"]},\"9\":{\"h\":\"C高级语言程序设计 笔记📒\"},\"10\":{\"h\":\"for循环\",\"t\":[\"for(表达式1；表达式2；表达式3) { 语句 } \",\"它的执行过程如下\",\"(1) 先求解表达式1\",\"(2)求解表达式2，若其值为真(值为非0)，则执行for语句中指定的内嵌语句，然后执行下面第(3)步。若为假(值为0)，则结束循环，转到第(5)步\",\"(3) 求解表达式3\",\"(4) 转回上面第(2)步继续执行\",\"(5) 循环结束\",\"for(循环变量赋初值；循环条件；循环变量增值)\"]},\"11\":{\"h\":\"定义一个一维数组\",\"t\":[\"a[10] 数组名a，有10个元素\",\"表示形式：数组名[下标]下标从0开始\"]},\"12\":{\"h\":\"初始化赋值\",\"t\":[\"对数组元素进行初始化赋值：int a [5] = {0, 1, 2, 3, 4};\",\"初始化之后：a [0] = 0, a [1] = 1 以此类推\",\"初始化时可以全赋值，之后只能引用赋值\",\"初始化时可以只赋值一部分，未赋值的元素为0\",\"对全部元素初始赋值时可以省略：a[]={0, 1, 2, 3, 4} ，系统会自动分配下标为5，但之后的元素不可省略\",\"定义数组下标必须使用常量，引用数组时下标可以是变量，表达式\"]},\"13\":{\"h\":\"定义一个二维数组\",\"t\":[\"数组名［常量表达式1］［常量表达式2］\",\"可看作一个特殊的一维数组：1*2的数组？\"]},\"14\":{\"h\":\"初始化\",\"t\":[\"类似一维数组\",\" int a［3］［4］={{1}，{5}，{9}};\",\"也可以部分赋值\"]},\"15\":{\"h\":\"注意\",\"t\":[\"数组要初始化\"]},\"16\":{\"h\":\"字符数组\",\"t\":[\"char c [10]{'w','ee'};\",\"用于存放字符，也可以用int来存储，但是浪费空间\",\"初始化类似，但缺少的部分自动补全为\\\\0\",\"使用%c输入输出\"]},\"17\":{\"h\":\"定义成字符串\",\"t\":[\"则用%s输出，遇到0结束\",\"char c[]={\\\"china\\\"}; printf(\\\"%s\\\",c); \",\"遇到0结束\"]},\"18\":{\"h\":\"输入输出\",\"t\":[\"printf(\\\"%s\\\",&c[0]);\",\"输入字符串时，保留多一位给\\\\0\"]},\"19\":{\"h\":\"如果包含空格\",\"t\":[\"只会输入空格之前的内容，若要输入包含空格只能定义多个字符串\"]},\"20\":{\"h\":\"输入\",\"t\":[\"输入项为字符组名时，不需要加入地址符&\",\"scanf(“%s”, Str);\"]},\"21\":{\"h\":\"使用字符串处理函数（有string.h头文件）\",\"t\":[\"puts(字符数组)其结果是输出数组，输出完毕后会增加换行（将\\\\0变为\\\\n）\",\"gets(字符数组)字符数=输入字符数量+1\",\"strcat(str1,str2)字符串连接，将str2连接到str1之后\",\"strcpy(str1,str2);将两个数组内容复制，只能通过内存拷贝\",\"strcmp(str1,str2);两个数组比较ascii码的值，从左到右，直到不同的字符或者\\\\0为止\",\"若1>2,则函数值为正整数，1<2，为负整数，以第一个不同的字符为准\",\"strlen(str)测试字符串的长度，不包括\\\\0在内\",\"strlwr：转小写 strupr：转大写\"]},\"22\":{\"h\":\"定义函数\",\"t\":[\"函数分为有参和无参\",\"有参是指函数与其他函数之间存在数据传递\",\"无参是指该函数并没有数据传递,一般只用于执行一组操作,可以带回或不带回函数值\",\"有函数参数的一般形式\",\"类型标识符 函数名(形式参数表列){ 声明部分 语句 } 例: int max（int x，int y） { int z; //函数体中的声明部分 z = x＞y？x : y ; return z； } \",\"可以有“空函数”\",\"如果用 void 定义函数,那么这个函数将没有返回值(定义为空类型)\"]},\"23\":{\"h\":\"调用函数\",\"t\":[\"将函数调用作为一个语句\",\"将函数放到表达式中\",\"调用作为一个函数实参\",\"被调用函数定义写在前面,那么主函数中不需要再写函数声明,如果定义写在后面则需要提前书写函数声明\"]},\"24\":{\"h\":\"函数调用时的数据传递\"},\"25\":{\"h\":\"形式参数和实际参数\",\"t\":[\"实际参数:实实在在确定的值,存在的\",\"只有发生函数调用时,函数中的形参才被分配内存单元\",\"实参可以是常量,变量或者表达式,但实参要有具体的值\",\"实参与形参的类型相同或赋值相容\",\"实参变量对形参变量的数据传递都是“直传递”,相当于拷贝的过程 只能由实参传给形参\"]},\"26\":{\"h\":\"函数的嵌套调用\",\"t\":[\"函数定义互相平行,可以嵌套调用\"]},\"27\":{\"h\":\"递归调用\",\"t\":[\"调用函数的过程中又直接或者间接调用该函数本身,称之为递归调用\"]},\"28\":{\"h\":\"数组作为函数的参数\",\"t\":[\"可以用数组名作为函数的参数,此时实参和形参都应该用数组名\",\"应该在主调函数和被调用函数中分别定义数组,同时实参和形参数组形式应该一致,否则可能出错\"]},\"29\":{\"h\":\"关于指针\",\"t\":[\"指针是一个值为内存地址的变量\",\"一个变量的地址称为该变量的指针\",\"指针变量实际情况下不知道实际整数值\",\"有两种引用方式，使用变量本身或者使用该变量的指针\"]},\"30\":{\"h\":\"定义指针\",\"t\":[\"类型名 *指针变量名保存地址类型相同，但是指向的类型不同\"]},\"31\":{\"h\":\"赋值语句运算符\",\"t\":[\"ptr = &pooh; // 把pooh的地址赋给ptr ptr = &bah; // 把ptr指向bah，而不是pooh val = *ptr; // 找出ptr指向的值 \",\"ptr = &bah; val = *ptr; 相当于 val = bah; \"]},\"32\":{\"h\":\"声明指针\",\"t\":[\"声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间\",\"int * pi; // pi是指向int类型变量的指针 char * pc; // pc是指向char类型变量的指针 float * pf, * pg; // pf、pg都是指向float类型变量的指针 \"]},\"33\":{\"h\":\"注意\",\"t\":[\"指针变量前面的*表示该变量的类型为指针变量，变量名不包括*\",\"定义指针变量时必须指定基类型\",\"指针变量之中只能存放地址，不能存放其他数据（虽然一般用不到，除非非常清楚内存地址，不然不会定义）\"]},\"34\":{\"h\":\"指针变量的引用\",\"t\":[\"给指针变量赋值\",\"引用指针变量指向的变量\",\"引用指针变量的值\",\"使用指针可以在不破坏变量原始值的前提下相互交换，比如在排序的时候可以使用指针，同时不破坏原来的输入\",\"（使用其他的方式来引用）\"]},\"35\":{\"h\":\"指针引用数组\",\"t\":[\"数组的指针就是该数组的地址\"]},\"36\":{\"h\":\"指针的运算\",\"t\":[\"p指向数组的一个元素，p+1指向下一个元素（并非将p的值简单的相加）\",\"p的初始值是&a[0]，则p+i和a+i是a[i]的地址\",\"(p+i)或(a+i)是p+i或a+i所指向的数组元素，即a[i]\",\"如果指针p和q都是指向同一数组，则执行q-p的结果是：地址q-地址p的差除以数组元素的长度\"]},\"37\":{\"h\":\"指向函数的指针\",\"t\":[\"函数指针的数据类型int(*p)(int,int);\",\"定义函数类型的指针，定义函数之后调用时增加括号\",\"p = max; \",\"int a = max(b,c); \",\"int a = (*p)(b,c);\",\"函数可以作为另一个函数的参数传递\"]},\"38\":{\"h\":\"一般形式\"},\"39\":{\"h\":\"结构体的声明\",\"t\":[\"struct 结构体名 { 类型名 成员名1； 类型名 成员名2； }； \"]},\"40\":{\"h\":\"引用结构体变量中成员的方式为\",\"t\":[\"结构体变量名.成员名\",\"数组所占内存变大\",\"结构体数组初始化与其他类型数组一样，可以直接初始化\"]},\"41\":{\"h\":\"声明新类型名\",\"t\":[\"typedef struct { int month; int day; int year; } DATE； \",\"表示声明新类型名DATE，它代表上面指定的一个结构体类型。这时就可以用DATE定义变量：\",\"DATE birthday；\",\"DATE *p；\"]},\"42\":{\"h\":\"链表\",\"t\":[\"根据数据开辟内存地址，避免浪费空间\",\"可以在结构体最后加入指针\"]},\"43\":{\"c\":[\"学习笔记\"]},\"44\":{\"c\":[\"C语言\",\"程序设计\"]},\"45\":{\"h\":\"C语言经典题\"},\"46\":{\"h\":\"判断闰年\",\"t\":[\"思路：判断整除4，整除100，不能整除400\",\"if (month==1||month==3||month==5||month==7||month==8||month==10||month==12){ day = 31; } if (month==4||month==6||month==9||month==11){ day = 30; } if (month==2){ if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0){ day = 29; } else { day = 28; } } \"]},\"47\":{\"h\":\"计算正整数的长度\",\"t\":[\"思路：若n!=0; n=n/10，则加一位数字\"]},\"48\":{\"h\":\"幂函数\",\"t\":[\"递归；运用for循环，直接将x乘y次\",\"int mypow(int x,int y) { int num=1; for (int i=1; i<=y; i++) { num*=x; } return num; } \"]},\"49\":{\"h\":\"判断回文数\",\"t\":[\"思路：一个数除以10所得到的余数便是个位数，商是排除掉最后一位的数，则经过循环之后便可以得到反转而来的数\",\"while (origin>0){ after=after*10+origin%10; origin=origin/10; } if(n==after){ printf(\\\"Yes\\\"); } else{ printf(\\\"No\\\"); } \",\"运用递归求解：不断向前推算\",\"void reverse(int n) { if (n < 10) { printf(\\\"%d\\\", n); return; } printf(\\\"%d\\\", n % 10); reverse(n / 10); } \",\"return 回去\",\"输出”要使用/\\\"来表示\",\"两个整数相除需要获得小数，那么将a/b转换成float形式，使用(float)a/b\",\"计算的时候遵循数学规律\",\"可以使用#define FORMATE\\\"%d\\\\n%d\\\\n\\\"类似的语句实现输出格式的定义，之后只需要printf(FORMATE,a,b);即可实现输出\"]},\"50\":{\"c\":[\"学习笔记\"]},\"51\":{\"c\":[\"C语言\",\"题目\"]},\"52\":{\"h\":\"Java高级语言程序设计 笔记📒\",\"t\":[\"标识符：$\",\"首字母不得是数字，区分大小写\",\"除去关键字\",\"（字母，数字，下划线，美元符号$）\",\"public static void main{} main方法\",\"System.out.println\",\"Public 本包均能访问\",\"protected 当前类的子类\",\"private 本类访问\",\"默认 本\",\"static 静态方法\",\"class 类\"]},\"53\":{\"h\":\"直接量\",\"t\":[\"布尔：boolean\",\"String字符串，null，基本数据\",\"long：34L\",\"float：1.5F\",\"char\",\"int\",\"转义字符\"]},\"54\":{\"h\":\"变量\",\"t\":[\"类型转换：自动：低级到高级\",\"目标类型 变量=(目标类型) 值\"]},\"55\":{\"h\":\"运算符\",\"t\":[\"Math.pow(2.0,3.0); $2.0^{3.0}$\",\"7/5=$7 div5$\",\"7%5=$7mod5$ 也可对浮点数运算，运算结果符号与第一个操作符的符号相同\"]},\"56\":{\"h\":\"布尔型\",\"t\":[\"& AND | OR ^ XOR ! NOT\",\"条件\",\"&& AND || OR\"]},\"57\":{\"h\":\"位运算符\",\"t\":[\"<< 左移\",\">> 右移\",\">>> 无符号右移\",\"写成二进制形式然后按位操作产生一个新的数\",\"instanceof\",\"new\",\"(Cond ? express1 : express2)\",\"行为方法功能等封装成类（classes）：具有共同特征的数据等\",\"对象（objects）：类的实例\",\"具有封装性，继承性，多态性\",\"基本思想：构建和组织对象解决问题\"]},\"58\":{\"h\":\"class\",\"t\":[\"是实例对象的模版\",\"基本组成：域和方法\",\"修饰词 class 类名称 extends父类名 implements接口名\",\"类修饰词：public 可被所有Java软件包使用\",\"abstract 抽象类\",\"final 最终类，不能被继承\",\"strictfp 浮点运算\",\"default 只能在当前包内使用\"]},\"59\":{\"h\":\"成员域\",\"t\":[\"表示和存储类所需要的数据\",\"域修饰词 类型 变量名或带初始化的变量名列表\",\"类型：当前成员域的类型 包括基本数据类型和引用数据类型\",\"方法修饰词 返回类型 方法名\",\"返回类型：返回数据的类型\",\"方法名：标识符\",\"参数列表：，分割\",\"方法修饰词：public protected private abstract static final synchronized strictfp\"]},\"60\":{\"h\":\"构造方法\",\"t\":[\"创建类的实例对象\",\"同时完成初始化\",\"默认构造方法：不含任何参数\",\"0 bool false\",\"格式\",\"【修饰词】类名称（参数）\",\"{\",\"方法体\",\"​ }\",\"定义顺序：成员域 构造方法 成员方法\",\"引用数据类型变量：四个基本属性：变量名，数据类型，变量值和存储单元\",\"Java不允许有多重继承：有多个父类\",\"类型转换\",\"隐式 子类型——>父类型 不用强制转换符（）\",\"显式 父类型——>子类型 需要用强制转换符\",\"instanceof 判断一个引用类型表达式所指向的实例对象是否是某引用类型的实例对象\",\"多态性：在类定义里出现多个构造方法或出现多个同名的成员方法。\",\"重载：同一个类中的同名方法在功能上的重载\",\"覆盖：子类和父类类体中均定义了具有相同声明的非静态成员方法，称为对父类的覆盖\",\"super 调用父类型被覆盖的成员方法\",\"this 当前类的对象\",\"package 创建包\",\"import 导入包\",\"java.lang java.math\",\"String.valueOf() 转换为字符串\",\"迭代器\",\"Java.util.Iterator 判断迭代器下一个位置上是否还有元素\"]},\"61\":{\"h\":\"枚举\",\"t\":[\"修饰词只能是public，或者默认值\",\"不能通过new运算符\",\"常用：switch语句，采用枚举常量标识符\"]},\"62\":{\"c\":[\"学习笔记\"]},\"63\":{\"c\":[\"Java\",\"程序设计\"]},\"64\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"65\":{\"h\":\"Posts\"},\"66\":{\"h\":\"Notes\"}},\"dirtCount\":0,\"index\":[[\"采用枚举常量标识符\",{\"1\":{\"61\":1}}],[\"常用\",{\"1\":{\"61\":1}}],[\"常量表达式2\",{\"1\":{\"13\":1}}],[\"常量表达式1\",{\"1\":{\"13\":1}}],[\"枚举\",{\"0\":{\"61\":1}}],[\"迭代器\",{\"1\":{\"60\":1}}],[\"导入包\",{\"1\":{\"60\":1}}],[\"创建包\",{\"1\":{\"60\":1}}],[\"创建类的实例对象\",{\"1\":{\"60\":1}}],[\"称为对父类的覆盖\",{\"1\":{\"60\":1}}],[\"称之为递归调用\",{\"1\":{\"27\":1}}],[\"子类和父类类体中均定义了具有相同声明的非静态成员方法\",{\"1\":{\"60\":1}}],[\"子类型\",{\"1\":{\"60\":1}}],[\"覆盖\",{\"1\":{\"60\":1}}],[\"同一个类中的同名方法在功能上的重载\",{\"1\":{\"60\":1}}],[\"同时完成初始化\",{\"1\":{\"60\":1}}],[\"同时不破坏原来的输入\",{\"1\":{\"34\":1}}],[\"同时实参和形参数组形式应该一致\",{\"1\":{\"28\":1}}],[\"重载\",{\"1\":{\"60\":1}}],[\"在类定义里出现多个构造方法或出现多个同名的成员方法\",{\"1\":{\"60\":1}}],[\"需要用强制转换符\",{\"1\":{\"60\":1}}],[\"父类型\",{\"1\":{\"60\":1}}],[\"显式\",{\"1\":{\"60\":1}}],[\">子类型\",{\"1\":{\"60\":1}}],[\">父类型\",{\"1\":{\"60\":1}}],[\">>>\",{\"1\":{\"57\":1}}],[\">>\",{\"1\":{\"57\":1}}],[\"隐式\",{\"1\":{\"60\":1}}],[\"java\",{\"1\":{\"60\":3},\"2\":{\"63\":1}}],[\"java不允许有多重继承\",{\"1\":{\"60\":1}}],[\"java高级语言程序设计\",{\"0\":{\"52\":1}}],[\"四个基本属性\",{\"1\":{\"60\":1}}],[\"​\",{\"1\":{\"60\":1}}],[\"参数\",{\"1\":{\"60\":1}}],[\"参数列表\",{\"1\":{\"59\":1}}],[\"格式\",{\"1\":{\"60\":1}}],[\"构造方法\",{\"0\":{\"60\":1},\"1\":{\"60\":1}}],[\"构建和组织对象解决问题\",{\"1\":{\"57\":1}}],[\"分割\",{\"1\":{\"59\":1}}],[\"返回数据的类型\",{\"1\":{\"59\":1}}],[\"返回类型\",{\"1\":{\"59\":2}}],[\"方法体\",{\"1\":{\"60\":1}}],[\"方法名\",{\"1\":{\"59\":2}}],[\"方法修饰词\",{\"1\":{\"59\":2}}],[\"包括基本数据类型和引用数据类型\",{\"1\":{\"59\":1}}],[\"当前类的对象\",{\"1\":{\"60\":1}}],[\"当前类的子类\",{\"1\":{\"52\":1}}],[\"当前成员域的类型\",{\"1\":{\"59\":1}}],[\"域修饰词\",{\"1\":{\"59\":1}}],[\"域和方法\",{\"1\":{\"58\":1}}],[\"成员方法\",{\"1\":{\"60\":1}}],[\"成员域\",{\"0\":{\"59\":1},\"1\":{\"60\":1}}],[\"成员名\",{\"1\":{\"40\":1}}],[\"成员名2\",{\"1\":{\"39\":1}}],[\"成员名1\",{\"1\":{\"39\":1}}],[\"浮点运算\",{\"1\":{\"58\":1}}],[\"最终类\",{\"1\":{\"58\":1}}],[\"抽象类\",{\"1\":{\"58\":1}}],[\"修饰词只能是public\",{\"1\":{\"61\":1}}],[\"修饰词\",{\"1\":{\"58\":1,\"60\":1}}],[\"是实例对象的模版\",{\"1\":{\"58\":1}}],[\"是p+i或a+i所指向的数组元素\",{\"1\":{\"36\":1}}],[\"基本组成\",{\"1\":{\"58\":1}}],[\"基本思想\",{\"1\":{\"57\":1}}],[\"基本数据\",{\"1\":{\"53\":1}}],[\"多态性\",{\"1\":{\"57\":1,\"60\":1}}],[\"继承性\",{\"1\":{\"57\":1}}],[\"具有封装性\",{\"1\":{\"57\":1}}],[\"具有共同特征的数据等\",{\"1\":{\"57\":1}}],[\"行为方法功能等封装成类\",{\"1\":{\"57\":1}}],[\"写成二进制形式然后按位操作产生一个新的数\",{\"1\":{\"57\":1}}],[\"无符号右移\",{\"1\":{\"57\":1}}],[\"无参是指该函数并没有数据传递\",{\"1\":{\"22\":1}}],[\"右移\",{\"1\":{\"57\":1}}],[\"左移\",{\"1\":{\"57\":1}}],[\"位运算符\",{\"0\":{\"57\":1}}],[\"条件\",{\"1\":{\"56\":1}}],[\"^\",{\"1\":{\"56\":1}}],[\"|\",{\"1\":{\"56\":1}}],[\"||\",{\"1\":{\"46\":1,\"56\":1}}],[\"也可对浮点数运算\",{\"1\":{\"55\":1}}],[\"也可以用int来存储\",{\"1\":{\"16\":1}}],[\"也可以部分赋值\",{\"1\":{\"14\":1}}],[\"7\",{\"1\":{\"55\":2}}],[\"运算结果符号与第一个操作符的符号相同\",{\"1\":{\"55\":1}}],[\"运算符\",{\"0\":{\"55\":1}}],[\"运用递归求解\",{\"1\":{\"49\":1}}],[\"运用for循环\",{\"1\":{\"48\":1}}],[\"值\",{\"1\":{\"54\":1}}],[\"值为0\",{\"1\":{\"10\":1}}],[\"值为非0\",{\"1\":{\"10\":1}}],[\"目标类型\",{\"1\":{\"54\":2}}],[\"低级到高级\",{\"1\":{\"54\":1}}],[\"自动\",{\"1\":{\"54\":1}}],[\"布尔型\",{\"0\":{\"56\":1}}],[\"布尔\",{\"1\":{\"53\":1}}],[\"静态方法\",{\"1\":{\"52\":1}}],[\"默认构造方法\",{\"1\":{\"60\":1}}],[\"默认\",{\"1\":{\"52\":1}}],[\"本\",{\"1\":{\"52\":1}}],[\"本类访问\",{\"1\":{\"52\":1}}],[\"本包均能访问\",{\"1\":{\"52\":1}}],[\"美元符号$\",{\"1\":{\"52\":1}}],[\"下划线\",{\"1\":{\"52\":1}}],[\"下标从0开始\",{\"1\":{\"11\":1}}],[\"下标\",{\"1\":{\"11\":1}}],[\"数据类型\",{\"1\":{\"60\":1}}],[\"数字\",{\"1\":{\"52\":1}}],[\"数组所占内存变大\",{\"1\":{\"40\":1}}],[\"数组的指针就是该数组的地址\",{\"1\":{\"35\":1}}],[\"数组作为函数的参数\",{\"0\":{\"28\":1}}],[\"数组要初始化\",{\"1\":{\"15\":1}}],[\"数组名\",{\"1\":{\"11\":1,\"13\":1}}],[\"数组名a\",{\"1\":{\"11\":1}}],[\"字母\",{\"1\":{\"52\":1}}],[\"字符串连接\",{\"1\":{\"21\":1}}],[\"字符数=输入字符数量+1\",{\"1\":{\"21\":1}}],[\"字符数组\",{\"0\":{\"16\":1},\"1\":{\"21\":2}}],[\"除去关键字\",{\"1\":{\"52\":1}}],[\"除非非常清楚内存地址\",{\"1\":{\"33\":1}}],[\"区分大小写\",{\"1\":{\"52\":1}}],[\"首字母不得是数字\",{\"1\":{\"52\":1}}],[\"$2\",{\"1\":{\"55\":1}}],[\"$\",{\"1\":{\"52\":1,\"55\":1}}],[\"标识符\",{\"1\":{\"52\":1,\"59\":1}}],[\"题目\",{\"2\":{\"51\":1}}],[\"即可实现输出\",{\"1\":{\"49\":1}}],[\"即a\",{\"1\":{\"36\":1}}],[\"之后只需要printf\",{\"1\":{\"49\":1}}],[\"之后只能引用赋值\",{\"1\":{\"12\":1}}],[\"计算的时候遵循数学规律\",{\"1\":{\"49\":1}}],[\"计算正整数的长度\",{\"0\":{\"47\":1}}],[\"两个整数相除需要获得小数\",{\"1\":{\"49\":1}}],[\"两个数组比较ascii码的值\",{\"1\":{\"21\":1}}],[\"来表示\",{\"1\":{\"49\":1}}],[\"要使用\",{\"1\":{\"49\":1}}],[\"回去\",{\"1\":{\"49\":1}}],[\"default\",{\"1\":{\"58\":1}}],[\"define\",{\"1\":{\"49\":1}}],[\"div5$\",{\"1\":{\"55\":1}}],[\"d\",{\"1\":{\"49\":4}}],[\"date\",{\"1\":{\"41\":3}}],[\"day\",{\"1\":{\"41\":1,\"46\":4}}],[\"<<\",{\"1\":{\"57\":1}}],[\"<\",{\"1\":{\"49\":1}}],[\"reverse\",{\"1\":{\"49\":2}}],[\"return\",{\"1\":{\"22\":1,\"48\":1,\"49\":2}}],[\"objects\",{\"1\":{\"57\":1}}],[\"or\",{\"1\":{\"56\":2}}],[\"origin=origin\",{\"1\":{\"49\":1}}],[\"origin>0\",{\"1\":{\"49\":1}}],[\"out\",{\"1\":{\"52\":1}}],[\"of\",{\"1\":{\"1\":1,\"2\":1}}],[\"商是排除掉最后一位的数\",{\"1\":{\"49\":1}}],[\"递归\",{\"1\":{\"48\":1}}],[\"递归调用\",{\"0\":{\"27\":1}}],[\"幂函数\",{\"0\":{\"48\":1}}],[\"extends父类名\",{\"1\":{\"58\":1}}],[\"express2\",{\"1\":{\"57\":1}}],[\"express1\",{\"1\":{\"57\":1}}],[\"else\",{\"1\":{\"46\":1,\"49\":1}}],[\"ee\",{\"1\":{\"16\":1}}],[\"整除100\",{\"1\":{\"46\":1}}],[\"判断迭代器下一个位置上是否还有元素\",{\"1\":{\"60\":1}}],[\"判断一个引用类型表达式所指向的实例对象是否是某引用类型的实例对象\",{\"1\":{\"60\":1}}],[\"判断回文数\",{\"0\":{\"49\":1}}],[\"判断整除4\",{\"1\":{\"46\":1}}],[\"判断闰年\",{\"0\":{\"46\":1}}],[\"思路\",{\"1\":{\"46\":1,\"47\":1,\"49\":1}}],[\"程序设计\",{\"2\":{\"44\":1,\"63\":1}}],[\"学习笔记\",{\"2\":{\"43\":1,\"50\":1,\"62\":1}}],[\"避免浪费空间\",{\"1\":{\"42\":1}}],[\"根据数据开辟内存地址\",{\"1\":{\"42\":1}}],[\"链表\",{\"0\":{\"42\":1}}],[\"这时就可以用date定义变量\",{\"1\":{\"41\":1}}],[\"它代表上面指定的一个结构体类型\",{\"1\":{\"41\":1}}],[\"它的执行过程如下\",{\"1\":{\"10\":1}}],[\"结构体数组初始化与其他类型数组一样\",{\"1\":{\"40\":1}}],[\"结构体变量名\",{\"1\":{\"40\":1}}],[\"结构体名\",{\"1\":{\"39\":1}}],[\"结构体的声明\",{\"0\":{\"39\":1}}],[\"指向函数的指针\",{\"0\":{\"37\":1}}],[\"指针的运算\",{\"0\":{\"36\":1}}],[\"指针引用数组\",{\"0\":{\"35\":1}}],[\"指针变量的引用\",{\"0\":{\"34\":1}}],[\"指针变量之中只能存放地址\",{\"1\":{\"33\":1}}],[\"指针变量前面的\",{\"1\":{\"33\":1}}],[\"指针变量名保存地址类型相同\",{\"1\":{\"30\":1}}],[\"指针变量实际情况下不知道实际整数值\",{\"1\":{\"29\":1}}],[\"指针是一个值为内存地址的变量\",{\"1\":{\"29\":1}}],[\"地址p的差除以数组元素的长度\",{\"1\":{\"36\":1}}],[\"地址q\",{\"1\":{\"36\":1}}],[\"或者默认值\",{\"1\":{\"61\":1}}],[\"或\",{\"1\":{\"36\":1}}],[\"的地址\",{\"1\":{\"36\":1}}],[\"并非将p的值简单的相加\",{\"1\":{\"36\":1}}],[\"比如在排序的时候可以使用指针\",{\"1\":{\"34\":1}}],[\"引用数据类型变量\",{\"1\":{\"60\":1}}],[\"引用数组时下标可以是变量\",{\"1\":{\"12\":1}}],[\"引用结构体变量中成员的方式为\",{\"0\":{\"40\":1}}],[\"引用指针变量的值\",{\"1\":{\"34\":1}}],[\"引用指针变量指向的变量\",{\"1\":{\"34\":1}}],[\"给指针变量赋值\",{\"1\":{\"34\":1}}],[\"虽然一般用不到\",{\"1\":{\"33\":1}}],[\"变量值和存储单元\",{\"1\":{\"60\":1}}],[\"变量名\",{\"1\":{\"60\":1}}],[\"变量名或带初始化的变量名列表\",{\"1\":{\"59\":1}}],[\"变量名不包括\",{\"1\":{\"33\":1}}],[\"变量=\",{\"1\":{\"54\":1}}],[\"变量\",{\"0\":{\"54\":1}}],[\"变量或者表达式\",{\"1\":{\"25\":1}}],[\"因为不同的变量类型占用不同的存储空间\",{\"1\":{\"32\":1}}],[\"声明新类型名\",{\"0\":{\"41\":1}}],[\"声明指针变量时必须指定指针所指向变量的类型\",{\"1\":{\"32\":1}}],[\"声明指针\",{\"0\":{\"32\":1}}],[\"声明部分\",{\"1\":{\"22\":1}}],[\"相当于\",{\"1\":{\"31\":1}}],[\"相当于拷贝的过程\",{\"1\":{\"25\":1}}],[\"找出ptr指向的值\",{\"1\":{\"31\":1}}],[\"valueof\",{\"1\":{\"60\":1}}],[\"val\",{\"1\":{\"31\":3}}],[\"void\",{\"1\":{\"22\":1,\"49\":1,\"52\":1}}],[\"而不是pooh\",{\"1\":{\"31\":1}}],[\"把ptr指向bah\",{\"1\":{\"31\":1}}],[\"把pooh的地址赋给ptr\",{\"1\":{\"31\":1}}],[\"赋值语句运算符\",{\"0\":{\"31\":1}}],[\"一个数除以10所得到的余数便是个位数\",{\"1\":{\"49\":1}}],[\"一个变量的地址称为该变量的指针\",{\"1\":{\"29\":1}}],[\"一般形式\",{\"0\":{\"38\":1}}],[\"一般只用于执行一组操作\",{\"1\":{\"22\":1}}],[\"关于指针\",{\"0\":{\"29\":1}}],[\"否则可能出错\",{\"1\":{\"28\":1}}],[\"应该在主调函数和被调用函数中分别定义数组\",{\"1\":{\"28\":1}}],[\"此时实参和形参都应该用数组名\",{\"1\":{\"28\":1}}],[\"直接量\",{\"0\":{\"53\":1}}],[\"直接将x乘y次\",{\"1\":{\"48\":1}}],[\"直传递\",{\"1\":{\"25\":1}}],[\"直到不同的字符或者\",{\"1\":{\"21\":1}}],[\"存在的\",{\"1\":{\"25\":1}}],[\"实参变量对形参变量的数据传递都是\",{\"1\":{\"25\":1}}],[\"实参与形参的类型相同或赋值相容\",{\"1\":{\"25\":1}}],[\"实参可以是常量\",{\"1\":{\"25\":1}}],[\"实实在在确定的值\",{\"1\":{\"25\":1}}],[\"实际参数\",{\"1\":{\"25\":1}}],[\"形式参数和实际参数\",{\"0\":{\"25\":1}}],[\"形式参数表列\",{\"1\":{\"22\":1}}],[\"那么将a\",{\"1\":{\"49\":1}}],[\"那么主函数中不需要再写函数声明\",{\"1\":{\"23\":1}}],[\"那么这个函数将没有返回值\",{\"1\":{\"22\":1}}],[\"被调用函数定义写在前面\",{\"1\":{\"23\":1}}],[\"调用父类型被覆盖的成员方法\",{\"1\":{\"60\":1}}],[\"调用作为一个函数实参\",{\"1\":{\"23\":1}}],[\"调用函数的过程中又直接或者间接调用该函数本身\",{\"1\":{\"27\":1}}],[\"调用函数\",{\"0\":{\"23\":1}}],[\"如果指针p和q都是指向同一数组\",{\"1\":{\"36\":1}}],[\"如果定义写在后面则需要提前书写函数声明\",{\"1\":{\"23\":1}}],[\"如果用\",{\"1\":{\"22\":1}}],[\"如果包含空格\",{\"0\":{\"19\":1}}],[\"空函数\",{\"1\":{\"22\":1}}],[\"z\",{\"1\":{\"22\":3}}],[\"yes\",{\"1\":{\"49\":1}}],[\"year\",{\"1\":{\"41\":1,\"46\":3}}],[\"y\",{\"1\":{\"22\":2,\"48\":1}}],[\"xor\",{\"1\":{\"56\":1}}],[\"x＞y\",{\"1\":{\"22\":1}}],[\"x\",{\"1\":{\"22\":2,\"48\":1}}],[\"例\",{\"1\":{\"22\":1}}],[\"函数可以作为另一个函数的参数传递\",{\"1\":{\"37\":1}}],[\"函数指针的数据类型int\",{\"1\":{\"37\":1}}],[\"函数定义互相平行\",{\"1\":{\"26\":1}}],[\"函数的嵌套调用\",{\"0\":{\"26\":1}}],[\"函数中的形参才被分配内存单元\",{\"1\":{\"25\":1}}],[\"函数调用时的数据传递\",{\"0\":{\"24\":1}}],[\"函数体中的声明部分\",{\"1\":{\"22\":1}}],[\"函数名\",{\"1\":{\"22\":1}}],[\"函数分为有参和无参\",{\"1\":{\"22\":1}}],[\"类修饰词\",{\"1\":{\"58\":1}}],[\"类名称\",{\"1\":{\"58\":1,\"60\":1}}],[\"类的实例\",{\"1\":{\"57\":1}}],[\"类\",{\"1\":{\"52\":1}}],[\"类似的语句实现输出格式的定义\",{\"1\":{\"49\":1}}],[\"类似一维数组\",{\"1\":{\"14\":1}}],[\"类型\",{\"1\":{\"59\":2}}],[\"类型转换\",{\"1\":{\"54\":1,\"60\":1}}],[\"类型名\",{\"1\":{\"30\":1,\"39\":2}}],[\"类型标识符\",{\"1\":{\"22\":1}}],[\"可被所有java软件包使用\",{\"1\":{\"58\":1}}],[\"可以使用\",{\"1\":{\"49\":1}}],[\"可以在结构体最后加入指针\",{\"1\":{\"42\":1}}],[\"可以直接初始化\",{\"1\":{\"40\":1}}],[\"可以用数组名作为函数的参数\",{\"1\":{\"28\":1}}],[\"可以嵌套调用\",{\"1\":{\"26\":1}}],[\"可以有\",{\"1\":{\"22\":1}}],[\"可以带回或不带回函数值\",{\"1\":{\"22\":1}}],[\"可看作一个特殊的一维数组\",{\"1\":{\"13\":1}}],[\"不用强制转换符\",{\"1\":{\"60\":1}}],[\"不含任何参数\",{\"1\":{\"60\":1}}],[\"不断向前推算\",{\"1\":{\"49\":1}}],[\"不能通过new运算符\",{\"1\":{\"61\":1}}],[\"不能被继承\",{\"1\":{\"58\":1}}],[\"不能整除400\",{\"1\":{\"46\":1}}],[\"不能存放其他数据\",{\"1\":{\"33\":1}}],[\"不然不会定义\",{\"1\":{\"33\":1}}],[\"不包括\",{\"1\":{\"21\":1}}],[\"不需要加入地址符\",{\"1\":{\"20\":1}}],[\"测试字符串的长度\",{\"1\":{\"21\":1}}],[\"以第一个不同的字符为准\",{\"1\":{\"21\":1}}],[\"以此类推\",{\"1\":{\"12\":1}}],[\"为负整数\",{\"1\":{\"21\":1}}],[\"从左到右\",{\"1\":{\"21\":1}}],[\"只能在当前包内使用\",{\"1\":{\"58\":1}}],[\"只能由实参传给形参\",{\"1\":{\"25\":1}}],[\"只能通过内存拷贝\",{\"1\":{\"21\":1}}],[\"只有发生函数调用时\",{\"1\":{\"25\":1}}],[\"只会输入空格之前的内容\",{\"1\":{\"19\":1}}],[\"gets\",{\"1\":{\"21\":1}}],[\"github\",{\"1\":{\"1\":1,\"2\":1}}],[\"new\",{\"1\":{\"57\":1}}],[\"null\",{\"1\":{\"53\":1}}],[\"num\",{\"1\":{\"48\":2}}],[\"num=1\",{\"1\":{\"48\":1}}],[\"notes\",{\"0\":{\"66\":1}}],[\"not\",{\"1\":{\"56\":1,\"64\":1}}],[\"no\",{\"1\":{\"49\":1}}],[\"now\",{\"1\":{\"1\":1,\"2\":1}}],[\"n==after\",{\"1\":{\"49\":1}}],[\"n=n\",{\"1\":{\"47\":1}}],[\"n\",{\"1\":{\"21\":1,\"49\":7}}],[\"将函数放到表达式中\",{\"1\":{\"23\":1}}],[\"将函数调用作为一个语句\",{\"1\":{\"23\":1}}],[\"将两个数组内容复制\",{\"1\":{\"21\":1}}],[\"将str2连接到str1之后\",{\"1\":{\"21\":1}}],[\"将\",{\"1\":{\"21\":1}}],[\"输出\",{\"1\":{\"49\":1}}],[\"输出完毕后会增加换行\",{\"1\":{\"21\":1}}],[\"输入项为字符组名时\",{\"1\":{\"20\":1}}],[\"输入\",{\"0\":{\"20\":1}}],[\"输入字符串时\",{\"1\":{\"18\":1}}],[\"输入输出\",{\"0\":{\"18\":1}}],[\"其结果是输出数组\",{\"1\":{\"21\":1}}],[\"有多个父类\",{\"1\":{\"60\":1}}],[\"有两种引用方式\",{\"1\":{\"29\":1}}],[\"有函数参数的一般形式\",{\"1\":{\"22\":1}}],[\"有参是指函数与其他函数之间存在数据传递\",{\"1\":{\"22\":1}}],[\"有string\",{\"0\":{\"21\":1}}],[\"有10个元素\",{\"1\":{\"11\":1}}],[\"保留多一位给\",{\"1\":{\"18\":1}}],[\"package\",{\"1\":{\"60\":1}}],[\"private\",{\"1\":{\"52\":1,\"59\":1}}],[\"println\",{\"1\":{\"52\":1}}],[\"printf\",{\"1\":{\"17\":1,\"18\":1,\"49\":4}}],[\"protected\",{\"1\":{\"52\":1,\"59\":1}}],[\"public\",{\"1\":{\"52\":2,\"58\":1,\"59\":1}}],[\"puts\",{\"1\":{\"21\":1}}],[\"p\",{\"1\":{\"37\":3,\"41\":1}}],[\"p的结果是\",{\"1\":{\"36\":1}}],[\"p的初始值是\",{\"1\":{\"36\":1}}],[\"p+i\",{\"1\":{\"36\":1}}],[\"p+1指向下一个元素\",{\"1\":{\"36\":1}}],[\"p指向数组的一个元素\",{\"1\":{\"36\":1}}],[\"pg都是指向float类型变量的指针\",{\"1\":{\"32\":1}}],[\"pg\",{\"1\":{\"32\":1}}],[\"pf\",{\"1\":{\"32\":2}}],[\"pc是指向char类型变量的指针\",{\"1\":{\"32\":1}}],[\"pc\",{\"1\":{\"32\":1}}],[\"pi是指向int类型变量的指针\",{\"1\":{\"32\":1}}],[\"pi\",{\"1\":{\"32\":1}}],[\"pow\",{\"1\":{\"55\":1}}],[\"pooh\",{\"1\":{\"31\":1}}],[\"posts\",{\"0\":{\"65\":1},\"1\":{\"1\":1,\"2\":1}}],[\"ptr\",{\"1\":{\"31\":5}}],[\"遇到0结束\",{\"1\":{\"17\":2}}],[\"使用其他的方式来引用\",{\"1\":{\"34\":1}}],[\"使用指针可以在不破坏变量原始值的前提下相互交换\",{\"1\":{\"34\":1}}],[\"使用指南\",{\"2\":{\"4\":1,\"5\":1,\"8\":1}}],[\"使用变量本身或者使用该变量的指针\",{\"1\":{\"29\":1}}],[\"使用字符串处理函数\",{\"0\":{\"21\":1}}],[\"使用\",{\"1\":{\"16\":1,\"49\":1}}],[\"但是指向的类型不同\",{\"1\":{\"30\":1}}],[\"但是浪费空间\",{\"1\":{\"16\":1}}],[\"但实参要有具体的值\",{\"1\":{\"25\":1}}],[\"但缺少的部分自动补全为\",{\"1\":{\"16\":1}}],[\"但之后的元素不可省略\",{\"1\":{\"12\":1}}],[\"用于存放字符\",{\"1\":{\"16\":1}}],[\"while\",{\"1\":{\"49\":1}}],[\"w\",{\"1\":{\"16\":1}}],[\"with\",{\"1\":{\"1\":1,\"2\":1}}],[\"will\",{\"1\":{\"1\":1,\"2\":1}}],[\"注意\",{\"0\":{\"15\":1,\"33\":1}}],[\"9\",{\"1\":{\"14\":1}}],[\"定义顺序\",{\"1\":{\"60\":1}}],[\"定义指针变量时必须指定基类型\",{\"1\":{\"33\":1}}],[\"定义指针\",{\"0\":{\"30\":1}}],[\"定义为空类型\",{\"1\":{\"22\":1}}],[\"定义函数之后调用时增加括号\",{\"1\":{\"37\":1}}],[\"定义函数类型的指针\",{\"1\":{\"37\":1}}],[\"定义函数\",{\"0\":{\"22\":1},\"1\":{\"22\":1}}],[\"定义成字符串\",{\"0\":{\"17\":1}}],[\"定义一个二维数组\",{\"0\":{\"13\":1}}],[\"定义一个一维数组\",{\"0\":{\"11\":1}}],[\"定义数组下标必须使用常量\",{\"1\":{\"12\":1}}],[\"系统会自动分配下标为5\",{\"1\":{\"12\":1}}],[\"对象\",{\"1\":{\"57\":1}}],[\"对全部元素初始赋值时可以省略\",{\"1\":{\"12\":1}}],[\"对数组元素进行初始化赋值\",{\"1\":{\"12\":1}}],[\"未赋值的元素为0\",{\"1\":{\"12\":1}}],[\"初始化类似\",{\"1\":{\"16\":1}}],[\"初始化\",{\"0\":{\"14\":1}}],[\"初始化时可以只赋值一部分\",{\"1\":{\"12\":1}}],[\"初始化时可以全赋值\",{\"1\":{\"12\":1}}],[\"初始化之后\",{\"1\":{\"12\":1}}],[\"初始化赋值\",{\"0\":{\"12\":1}}],[\"0^\",{\"1\":{\"55\":1}}],[\"0在内\",{\"1\":{\"21\":1}}],[\"0为止\",{\"1\":{\"21\":1}}],[\"0变为\",{\"1\":{\"21\":1}}],[\"0\",{\"1\":{\"12\":4,\"16\":1,\"18\":2,\"36\":1,\"46\":3,\"55\":3,\"60\":1}}],[\"=x\",{\"1\":{\"48\":1}}],[\"=0\",{\"1\":{\"47\":1}}],[\"==\",{\"1\":{\"46\":2}}],[\"=\",{\"1\":{\"12\":4,\"14\":1,\"17\":1,\"22\":1,\"31\":6,\"37\":3,\"46\":5}}],[\"表示和存储类所需要的数据\",{\"1\":{\"59\":1}}],[\"表示声明新类型名date\",{\"1\":{\"41\":1}}],[\"表示该变量的类型为指针变量\",{\"1\":{\"33\":1}}],[\"表示形式\",{\"1\":{\"11\":1}}],[\"表达式\",{\"1\":{\"12\":1}}],[\"表达式3\",{\"1\":{\"10\":1}}],[\"表达式2\",{\"1\":{\"10\":1}}],[\"表达式1\",{\"1\":{\"10\":1}}],[\"循环变量增值\",{\"1\":{\"10\":1}}],[\"循环变量赋初值\",{\"1\":{\"10\":1}}],[\"循环条件\",{\"1\":{\"10\":1}}],[\"循环结束\",{\"1\":{\"10\":1}}],[\"转换为字符串\",{\"1\":{\"60\":1}}],[\"转义字符\",{\"1\":{\"53\":1}}],[\"转大写\",{\"1\":{\"21\":1}}],[\"转小写\",{\"1\":{\"21\":1}}],[\"转回上面第\",{\"1\":{\"10\":1}}],[\"转到第\",{\"1\":{\"10\":1}}],[\"404\",{\"1\":{\"64\":1}}],[\"400\",{\"1\":{\"46\":1}}],[\"4\",{\"1\":{\"10\":1,\"12\":2,\"14\":1,\"46\":1}}],[\"求解表达式3\",{\"1\":{\"10\":1}}],[\"求解表达式2\",{\"1\":{\"10\":1}}],[\"5=$7mod5$\",{\"1\":{\"55\":1}}],[\"5=$7\",{\"1\":{\"55\":1}}],[\"5f\",{\"1\":{\"53\":1}}],[\"5\",{\"1\":{\"10\":2,\"12\":1,\"14\":1}}],[\"则经过循环之后便可以得到反转而来的数\",{\"1\":{\"49\":1}}],[\"则加一位数字\",{\"1\":{\"47\":1}}],[\"则执行q\",{\"1\":{\"36\":1}}],[\"则执行for语句中指定的内嵌语句\",{\"1\":{\"10\":1}}],[\"则p+i和a+i是a\",{\"1\":{\"36\":1}}],[\"则函数值为正整数\",{\"1\":{\"21\":1}}],[\"则用\",{\"1\":{\"17\":1}}],[\"则结束循环\",{\"1\":{\"10\":1}}],[\"若n\",{\"1\":{\"47\":1}}],[\"若1>2\",{\"1\":{\"21\":1}}],[\"若要输入包含空格只能定义多个字符串\",{\"1\":{\"19\":1}}],[\"若为假\",{\"1\":{\"10\":1}}],[\"若其值为真\",{\"1\":{\"10\":1}}],[\"步继续执行\",{\"1\":{\"10\":1}}],[\"步\",{\"1\":{\"10\":2}}],[\"34l\",{\"1\":{\"53\":1}}],[\"30\",{\"1\":{\"46\":1}}],[\"31\",{\"1\":{\"46\":1}}],[\"3\",{\"1\":{\"10\":2,\"12\":2,\"14\":1,\"55\":2}}],[\"然后执行下面第\",{\"1\":{\"10\":1}}],[\"28\",{\"1\":{\"46\":1}}],[\"29\",{\"1\":{\"46\":1}}],[\"2的数组\",{\"1\":{\"13\":1}}],[\"2\",{\"1\":{\"10\":2,\"12\":2,\"55\":1}}],[\"先求解表达式1\",{\"1\":{\"10\":1}}],[\"1<2\",{\"1\":{\"21\":1}}],[\"10+origin\",{\"1\":{\"49\":1}}],[\"100\",{\"1\":{\"46\":1}}],[\"10\",{\"1\":{\"11\":1,\"16\":1,\"47\":1,\"49\":5}}],[\"1\",{\"1\":{\"10\":1,\"12\":4,\"13\":1,\"14\":1,\"53\":1}}],[\"语句\",{\"1\":{\"10\":1,\"22\":1}}],[\"语言\",{\"1\":{\"3\":1,\"6\":1}}],[\"found\",{\"1\":{\"64\":1}}],[\"formate\",{\"1\":{\"49\":2}}],[\"for\",{\"1\":{\"10\":2,\"48\":1}}],[\"for循环\",{\"0\":{\"10\":1}}],[\"false\",{\"1\":{\"60\":1}}],[\"final\",{\"1\":{\"58\":1,\"59\":1}}],[\"float\",{\"1\":{\"32\":1,\"49\":1,\"53\":1}}],[\"from\",{\"1\":{\"1\":1,\"2\":1}}],[\"笔记📒\",{\"0\":{\"9\":1,\"52\":1}}],[\"cond\",{\"1\":{\"57\":1}}],[\"code\",{\"1\":{\"1\":1,\"2\":1}}],[\"coding\",{\"1\":{\"1\":1,\"2\":1}}],[\"classes\",{\"1\":{\"57\":1}}],[\"class\",{\"0\":{\"58\":1},\"1\":{\"52\":1,\"58\":1}}],[\"c语言经典题\",{\"0\":{\"45\":1}}],[\"c语言\",{\"2\":{\"44\":1,\"51\":1}}],[\"china\",{\"1\":{\"17\":1}}],[\"char\",{\"1\":{\"16\":1,\"17\":1,\"32\":1,\"53\":1}}],[\"c输入输出\",{\"1\":{\"16\":1}}],[\"c\",{\"1\":{\"16\":1,\"17\":2,\"18\":1,\"37\":2}}],[\"c高级语言程序设计\",{\"0\":{\"9\":1}}],[\"工具\",{\"2\":{\"7\":1}}],[\"页面配置\",{\"2\":{\"5\":1,\"8\":1}}],[\"h头文件\",{\"0\":{\"21\":1}}],[\"html\",{\"1\":{\"3\":1,\"6\":1}}],[\"hi\",{\"0\":{\"1\":1}}],[\"和\",{\"1\":{\"3\":1,\"6\":1}}],[\"支持\",{\"1\":{\"3\":1,\"6\":1}}],[\"博客文章内容\",{\"1\":{\"3\":1,\"6\":1}}],[\"博客文章样例2\",{\"0\":{\"6\":1}}],[\"博客文章样例\",{\"0\":{\"3\":1}}],[\"个人介绍\",{\"0\":{\"2\":1}}],[\"lang\",{\"1\":{\"60\":1}}],[\"long\",{\"1\":{\"53\":1}}],[\"life\",{\"1\":{\"1\":1,\"2\":1}}],[\"learn\",{\"1\":{\"1\":1,\"2\":1}}],[\"switch语句\",{\"1\":{\"61\":1}}],[\"super\",{\"1\":{\"60\":1}}],[\"synchronized\",{\"1\":{\"59\":1}}],[\"system\",{\"1\":{\"52\":1}}],[\"static\",{\"1\":{\"52\":2,\"59\":1}}],[\"string\",{\"1\":{\"60\":1}}],[\"string字符串\",{\"1\":{\"53\":1}}],[\"strictfp\",{\"1\":{\"58\":1,\"59\":1}}],[\"struct\",{\"1\":{\"39\":1,\"41\":1}}],[\"strupr\",{\"1\":{\"21\":1}}],[\"strlwr\",{\"1\":{\"21\":1}}],[\"strlen\",{\"1\":{\"21\":1}}],[\"strcmp\",{\"1\":{\"21\":1}}],[\"strcpy\",{\"1\":{\"21\":1}}],[\"strcat\",{\"1\":{\"21\":1}}],[\"str2\",{\"1\":{\"21\":3}}],[\"str1\",{\"1\":{\"21\":3}}],[\"str\",{\"1\":{\"20\":1,\"21\":1}}],[\"student\",{\"1\":{\"1\":1,\"2\":1}}],[\"scanf\",{\"1\":{\"20\":1}}],[\"s\",{\"1\":{\"17\":1,\"18\":1,\"20\":1}}],[\"s输出\",{\"1\":{\"17\":1}}],[\"something\",{\"1\":{\"1\":1,\"2\":1}}],[\"util\",{\"1\":{\"60\":1}}],[\"use\",{\"1\":{\"1\":1,\"2\":1}}],[\"university\",{\"1\":{\"1\":1,\"2\":1}}],[\"this\",{\"1\":{\"60\":1}}],[\"there\",{\"0\":{\"1\":1}}],[\"typedef\",{\"1\":{\"41\":1}}],[\"to\",{\"1\":{\"1\":2,\"2\":2}}],[\"trying\",{\"1\":{\"1\":1,\"2\":1}}],[\"telecommunications\",{\"1\":{\"1\":1,\"2\":1}}],[\"bool\",{\"1\":{\"60\":1}}],[\"boolean\",{\"1\":{\"53\":1}}],[\"b转换成float形式\",{\"1\":{\"49\":1}}],[\"birthday\",{\"1\":{\"41\":1}}],[\"b\",{\"1\":{\"37\":2,\"49\":2}}],[\"bah\",{\"1\":{\"31\":3}}],[\"better\",{\"1\":{\"1\":1,\"2\":1}}],[\"be\",{\"1\":{\"1\":1,\"2\":1}}],[\"beijing\",{\"1\":{\"1\":1,\"2\":1}}],[\"buterr的blog\",{\"0\":{\"0\":1},\"1\":{\"0\":1}}],[\"abstract\",{\"1\":{\"58\":1,\"59\":1}}],[\"about\",{\"1\":{\"1\":1,\"2\":1}}],[\"after=after\",{\"1\":{\"49\":1}}],[\"a+i\",{\"1\":{\"36\":1}}],[\"and\",{\"1\":{\"1\":1,\"2\":1,\"56\":2}}],[\"a\",{\"1\":{\"1\":1,\"2\":1,\"11\":1,\"12\":4,\"14\":1,\"36\":1,\"37\":2,\"49\":2}}],[\"mypow\",{\"1\":{\"48\":1}}],[\"month==2\",{\"1\":{\"46\":1}}],[\"month==4||month==6||month==9||month==11\",{\"1\":{\"46\":1}}],[\"month==1||month==3||month==5||month==7||month==8||month==10||month==12\",{\"1\":{\"46\":1}}],[\"month\",{\"1\":{\"41\":1}}],[\"math\",{\"1\":{\"55\":1,\"60\":1}}],[\"main方法\",{\"1\":{\"52\":1}}],[\"main\",{\"1\":{\"52\":1}}],[\"max\",{\"1\":{\"22\":1,\"37\":2}}],[\"markdown\",{\"1\":{\"3\":1,\"6\":1}}],[\"m\",{\"1\":{\"1\":2,\"2\":2}}],[\"iterator\",{\"1\":{\"60\":1}}],[\"import\",{\"1\":{\"60\":1}}],[\"implements接口名\",{\"1\":{\"58\":1}}],[\"instanceof\",{\"1\":{\"57\":1,\"60\":1}}],[\"int\",{\"1\":{\"12\":1,\"14\":1,\"22\":4,\"32\":1,\"37\":4,\"41\":3,\"48\":5,\"49\":1,\"53\":1}}],[\"i++\",{\"1\":{\"48\":1}}],[\"i<=y\",{\"1\":{\"48\":1}}],[\"i=1\",{\"1\":{\"48\":1}}],[\"if\",{\"1\":{\"46\":4,\"49\":2}}],[\"i\",{\"1\":{\"1\":2,\"2\":2,\"36\":2}}],[\"👋\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
