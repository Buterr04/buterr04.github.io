# 循环

## for循环

```c
for(表达式1；表达式2；表达式3) 
{
	语句
}
```

它的执行过程如下

  **(1)** 先求解表达式1

  **(2)** **求解表达式2**，若其值为真(值为非0)，则执行for语句中指定的内嵌语句，然后执行下面**第(3)步**。若为假(值为0)，则结束循环，转到**第(5)步**

  **(3)** 求解**表达式3**

  **(4)** 转回上面**第(2)步**继续执行

  **(5)** 循环结束

`for(循环变量赋初值；循环条件；循环变量增值)`



------

# 数组

## 定义一个一维数组

` a[10] ` 数组名a，有10个元素

表示形式：` 数组名[下标] `  ==下标从0开始==

### 初始化赋值

* 对数组元素进行初始化赋值：` int a [5] = {0, 1, 2, 3, 4}; `
  * 初始化之后：` a [0] = 0, a [1] = 1 以此类推 `

* 初始化时可以全赋值，之后只能引用赋值
* 初始化时可以只赋值一部分，未赋值的元素为0
* 对全部元素初始赋值时可以省略：` a[]={0, 1, 2, 3, 4} ` ，系统会自动分配下标为5，但之后的元素不可省略

==定义数组下标必须使用常量，引用数组时下标可以是变量，表达式==

## 定义一个二维数组

` 数组名［常量表达式1］［常量表达式2］ `

可看作一个特殊的一维数组：1*2的数组？

### 初始化

* 类似一维数组
* ` int a［3］［4］={{1}，{5}，{9}};`
* 也可以部分赋值



### 注意

1. 数组要初始化

   

## 字符数组

`char c [10]{'w','ee'};`

用于存放字符，也可以用`int`来存储，但是浪费空间

初始化类似，但缺少的部分自动补全为`\0`

使用`%c`输入输出

### 定义成字符串

则用`%s`输出，遇到0结束

```c
char c[]={"china"};

printf("%s",c);
```

遇到0结束

### 输入输出

`printf("%s",&c[0]);`

输入字符串时，保留多一位给`\0`

#### 如果包含空格

只会输入空格之前的内容，若要输入包含空格只能定义多个字符串

#### 输入

输入项为字符组名时，不需要加入地址符&

`scanf(“%s”, Str);`

#### 使用字符串处理函数（有string.h头文件）

- `puts(字符数组)`其结果是输出数组，输出完毕后会增加换行（将\0变为\n）

- `gets(字符数组)`字符数=输入字符数量+1
- `strcat(str1,str2)`字符串连接，将str2连接到str1之后

- `strcpy(str1,str2);`将两个数组内容复制，只能通过内存拷贝

- `strcmp(str1,str2);`两个数组比较ascii码的值，从左到右，直到不同的字符或者\0为止

  若1>2,则函数值为正整数，1<2，为负整数，以第一个不同的字符为准

- `strlen(str)`测试字符串的长度，==不包括\0在内==
- `strlwr`：转小写				`strupr`：转大写



------

# 函数

## 定义函数

- 函数分为有参和无参
  - 有参是指函数与其他函数之间存在数据传递
  - 无参是指该函数并没有数据传递,一般只用于执行一组操作,可以带回或不带回函数值

- 有函数参数的一般形式

```c
类型标识符 函数名(形式参数表列){
	声明部分
	语句
}

例:
int max（int x，int y）
	{
	 	int  z;		     //函数体中的声明部分
		z = x＞y？x : y ;
      	return  z；
	}
```

- 可以有“空函数”
- 如果用 `void` 定义函数,那么这个函数将没有返回值(定义为空类型)

## 调用函数

- 将函数调用作为一个语句
- 将函数放到表达式中
- 调用作为一个函数实参
- 被调用函数定义写在前面,那么主函数中不需要再写函数声明,如果定义写在后面则需要提前书写函数声明

## 函数调用时的数据传递

### 形式参数和实际参数

实际参数:实实在在确定的值,存在的

只有发生函数调用时,函数中的形参才被分配内存单元

实参可以是常量,变量或者表达式,但实参要有具体的值

实参与形参的类型相同或赋值相容

实参变量对形参变量的数据传递都是“直传递”,相当于拷贝的过程 ==只能由实参传给形参==

### 函数的嵌套调用

函数定义互相平行,可以嵌套调用

### 递归调用

调用函数的过程中又直接或者间接调用该函数本身,称之为递归调用

### 数组作为函数的参数

可以用数组名作为函数的参数,此时实参和形参都应该用数组名

应该在主调函数和被调用函数中分别定义数组,同时实参和形参数组形式应该一致,否则可能出错



# 指针

## 关于指针

指针是一个值为内存地址的变量

一个变量的地址称为该变量的指针

指针变量实际情况下不知道实际整数值

有两种引用方式，使用变量本身或者使用该变量的指针

## 定义指针

`类型名 *指针变量名` 	**保存地址类型相同，但是指向的类型不同**

## 赋值语句运算符

```c
ptr = &pooh; // 把pooh的地址赋给ptr
ptr = &bah; // 把ptr指向bah，而不是pooh
val = *ptr; // 找出ptr指向的值
```

```c
ptr = &bah;
val = *ptr;
相当于	val = bah;
```

## 声明指针

声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间

```c
int * pi;   // pi是指向int类型变量的指针
char * pc;    // pc是指向char类型变量的指针
float * pf, * pg; // pf、pg都是指向float类型变量的指针
```

### 注意

指针变量前面的`*`表示该变量的类型为指针变量，变量名不包括`*`

定义指针变量时必须指定基类型

指针变量之中只能存放地址，不能存放其他数据（虽然一般用不到，除非非常清楚内存地址，不然不会定义）

## 指针变量的引用

1. 给指针变量赋值
2. 引用指针变量指向的变量
3. 引用指针变量的值

使用指针可以在不破坏变量原始值的前提下相互交换，比如在排序的时候可以使用指针，同时不破坏原来的输入

（使用其他的方式来引用）

## 指针引用数组

数组的指针就是该数组的地址

### 指针的运算

p指向数组的一个元素，p+1指向下一个元素（并非将p的值简单的相加）

p的初始值是&a[0]，则p+i和a+i是a[i]的地址

(p+i)或(a+i)是p+i或a+i所指向的数组元素，即a[i]

如果指针p和q都是指向同一数组，则执行q-p的结果是：地址q-地址p的差除以数组元素的长度

## 指向函数的指针

函数指针的数据类型`int(*p)(int,int);`

定义函数类型的指针，定义函数之后调用时增加括号

`p = max; `

`int a = max(b,c); `

`int a = (*p)(b,c);`

函数可以作为另一个函数的参数传递

# 结构体变量

## 一般形式

### 结构体的声明

```c
struct 结构体名
{
类型名 成员名1；
类型名 成员名2；
}；
```

### 引用结构体变量中成员的方式为

 `结构体变量名.成员名`

数组所占内存变大

结构体数组初始化与其他类型数组一样，可以直接初始化

### 声明新类型名

```c
typedef　struct
{
	int　month;
	int　day;
	int　year;
 } DATE；

```

表示声明新类型名DATE，它代表上面指定的一个结构体类型。这时就可以用DATE定义变量：

DATE birthday；

DATE　*p； 

## 链表

根据数据开辟内存地址，避免浪费空间

可以在结构体最后加入指针

